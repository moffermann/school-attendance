// Simple IndexedDB wrapper
const IDB={dbName:'teacherPWA',version:1,db:null,async open(){return new Promise((resolve,reject)=>{const req=indexedDB.open(this.dbName,this.version);req.onerror=()=>reject(req.error);req.onsuccess=()=>{this.db=req.result;resolve(this.db);};req.onupgradeneeded=e=>{const db=e.target.result;['teachers','courses','rosters','students','attendance_local','queue','config'].forEach(name=>{if(!db.objectStoreNames.contains(name)){db.createObjectStore(name,{keyPath:'id',autoIncrement:true});}});};});},async get(store,key){if(!this.db)await this.open();return new Promise(resolve=>{const tx=this.db.transaction(store,'readonly');const req=tx.objectStore(store).get(key);req.onsuccess=()=>resolve(req.result);});},async getAll(store){if(!this.db)await this.open();return new Promise(resolve=>{const tx=this.db.transaction(store,'readonly');const req=tx.objectStore(store).getAll();req.onsuccess=()=>resolve(req.result||[]);});},async put(store,data){if(!this.db)await this.open();return new Promise(resolve=>{const tx=this.db.transaction(store,'readwrite');const req=tx.objectStore(store).put(data);req.onsuccess=()=>resolve(req.result);});},async clear(store){if(!this.db)await this.open();return new Promise(resolve=>{const tx=this.db.transaction(store,'readwrite');const req=tx.objectStore(store).clear();req.onsuccess=()=>resolve();});}};
